# Default configuration for tcm-piv

# Maintenance:
# - Treat this file as the single source of truth for defaults.
#   The Python loader merges user config over these defaults and should not
#   duplicate defaults in code.
# - Keep tables only one level deep (e.g. `[section] key = value`).
# - TOML has no `null`. Use empty string "" as “not provided” for optional paths.
# - For “tuple-like” values, use arrays like `[w, h]`; for per-pass tuple values,
#   use arrays-of-arrays like `[[w, h], [w2, h2], ...]`.

# Notes:
# - This file is packaged with the library and provides fallbacks.
# - User configs override these values.
# - Per-pass parameters (marked with *) may be a scalar (which will be broadcast)
#   or a list of length `nr_passes`.
# - All "dir" parameters can be left empty "" to provide user with file picker.

# How many times we refine the window size
nr_passes = 1

[source]
# (Relative) path to the directory containing your .tif high-speed images
image_dir = ""
# (Relative) path to the directory where all processed data and results will be saved
output_dir = ""
# A list of frames (ints) to use or the word "all"
frames_to_use = "all"

[camera]
# (Relative) path to the camera .cihx metadata file, a processed JSON metadata file or the directory containing either
camera_dir = ""
# (Relative) path to the calibration .tif image file (circle grid), a processed JSON metadata file or the directory containing either
calib_dir = ""
# Spacing between the circles in the circle grid (float in mm)
calib_spacing_mm = 1.0

[preprocessing]
# Background image to subtract.
# - "": not provided, will ask to generate
# - "none": skip background subtraction and skip generation prompt
background_dir = ""

# Crop ROI (y_start, y_end, x_start, x_end)
# y_end/x_end: 0 means full extent; negative means offset from end.
crop_roi = [0, 0, 0, 0]

# *Sum pixels over squares of size (downsample_factor x downsample_factor)
downsample_factor = 1      # or [f1, f2, ...]

[correlation]
# *Number of correlation maps (time steps) that will be summed before starting
# peak detection. Fancy averaging in time, basically.
corrs_to_sum = 1

# *Number of interrogation windows as [n_y, n_x]
nr_windows = [1, 1]        # or [[n_y, n_x], [n_y2, n_x2], ...]

# *Overlap fraction between windows (0 means no overlap)
window_overlap = 0.0       # 0..1

[displacement]
# *Number of peaks to save (to have multiple candidates to work with)
nr_peaks = 1

# *Minimum distance between peaks (in pixels)
min_peak_distance = 5

[postprocessing]
# *Global outlier filter mode: "semicircle_rect" or "circle".
# May be a scalar (broadcast to all passes) or a per-pass array.
outlier_filter_mode = "semicircle_rect"

# *Max velocity components [vy, vx] to use for the filter (they are absolute!)
max_velocity = [75.0, 10.0]

# Which in-plane velocity component represents the flow direction: "x" or "y"
flow_direction = "x"

# Out of plane dimension channel size (m)
extra_vel_dim_m = 0.01

# *Size of neighbourhood to consider for local filtering
# (time, y, x - includes itself as center point)
neighbourhood_size = [3, 3, 3]

# *How many standard deviations can a displacement be different from its neighbourhood
neighbourhood_threshold = 1

# *Smoothing parameter (larger = smoother). Works only on single window pass.
time_smoothing_lambda = 0.0

[visualisation]
plot_model = false
model_gender = "male"
model_mass = 70.0
model_height = 1.93
plot_global_filters = false
plot_correlations = false
plot_window_layout = false
plot_flow_rate = false
export_velocity_profiles_pdf = false